<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Decoration</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/2.0.0/modern-normalize.min.css"
    />

    <link rel="stylesheet" href="./CSS/style.css" />
  </head>
  <body class="body">
    <header class="header">
      <div class="container">
        <h3 class="title">Псевдо элементы</h3>
        <p>
          Псевдо элементы <b>::before и ::after</b> используются для добавления
          декоративных элементов (иконок, плашек, оверлеев) без необходимости
          создания дополнительных пустых тегов в разметке.
        </p>
        <ul>
          <li>
            <b>::before</b> - создает псевдо элемент перед всем контентом
            элемента (вначале)
          </li>
          <li>
            <b>::after</b> - создает псевдо элемент после всего контента
            элемента (вконце)
          </li>
        </ul>
        <div class="bg">
          <p>
            .box { <br />

            /* стили элемента */ <br />
            } <br /><br />
            .box::before { <br />
            /* стили псевдоэлемент before */ <br />
            } <br /><br />.box::after { <br />/* стили псевдоэлемент after */
            <br />
            }
          </p>
        </div>

        <p class="information">
          По умолчанию это строчный элемент. Для того, чтобы задать псевдо
          элементу вертикальную геометрию необходимо изменить его тип на блочный
          или строчно-блочный.
        </p>
        <h3 class="title">Свойство content</h3>
        <p>
          Это обязательное свойство позволяет добавить текстовый контент внутрь
          псевдо элемента. Даже если текстовый контент не нужен, его значение
          необходимо поставить пустым (пустую строку), иначе браузер просто не
          создаст псевдо элемент.
        </p>
        <div class="bg">
          <p>
            &lt;div class=&quot;box&quot;&gt; <br />
            Lorem, ipsum dolor sit amet consectetur adipisicing elit. Officia
            itaque quia nobis fugit amet adipisci, corrupti animi, iusto eius a
            sed totam voluptas porro. Dolorem aliquid rerum magnam eligendi
            aspernatur. <br />
            &lt;/div&gt;
          </p>
        </div>
        <p>
          В селекторе можно использовать только один псевдо элемент, который
          должен добавлятся после простого селектора (тега, класса,
          индификатора).
        </p>
        <div class="bg">
          <p>
            .box::before { <br />
            content: 'Это текст в ::before'; <br />
            font-size: 40px; <br />
            color: orange; <br />
            } <br /><br />
            .box::after { <br />
            content: 'Это текст в ::after';<br />
            font-size: 30px; color: teal;<br />
            }
          </p>
        </div>
        <p class="warning">
          Не используйте псевдо элемент для добавления текстового контента, это
          грубое нарушение спецификации. Они служат исключительно для
          декоративного оформления. Текст внутри псевдо элемента не
          воспринимается ассистивными и индексаторами, а так же будет не
          доступен пользователю, если не загрузится файл стилей.
        </p>
        <h3 class="title">Псевдо класс :hover</h3>
        <p>
          Для того чтобы изменить стили псевдо элемента при событии на
          родительском элементе, например ховер необходимо использовать след
          селетор
        </p>
        <div class="bg">
          <p>
            /* Применить стили к псевдоэлементу .box::before при ховере по
            элементу .box */ <br />
            .box:hover::before { <br />
            color: green; <br />
            } <br /><br />

            /* Применить стили к псевдоэлементу .box::after при ховере по
            элементу .box */ <br />
            .box:hover::after { <br />
            color: tomato;<br />
            }
          </p>
        </div>
        <h3 class="title">Псевдо элемент-иконка</h3>
        <p>
          Используя псевдо элементы добавим иконки перед и после ссылок в
          списке. Before будет виден всегда, а after только при ховере по
          ссылке.
        </p>
        <ul class="list">
          <li class="list-item"><a href="" class="list-link">Home</a></li>
          <li class="list-item"><a href="" class="list-link">Portfolio</a></li>
          <li class="list-item"><a href="" class="list-link">Team</a></li>
          <li class="list-item"><a href="" class="list-link">About</a></li>
        </ul>
        <p>
          Самое важное находится в этом css правиле. Измянем тип элемента на
          строчно-блочный и задаем фиксированую высоту и ширину. Так же не
          забываем указывать свойство контента пустой строкой, чтобы браузер
          создал псевдо элемент.
        </p>
        <div class="bg">
          <p>
            .list-link::before, <br />
            .list-link::after { <br />
            content: ''; <br />
            display: inline-block; <br />
            width: 24px; <br />
            height: 24px; <br />
            }
          </p>
        </div>
        <div class="overlay"></div>
        <h3 class="title">Тень элемнта</h3>
        <p>
          Тень добаляет элементу эффект объемности и ощущение высоты. Тени
          бывают внешние и внутренние, размытые и плоские, одинарные и
          многослойные.
        </p>
        <div class="bg"><img src="./image/shadow.jpg" alt="" /></div>
        <p>
          Свойство <b>box-shadow</b> задает элементу одну или более теней. По
          умолчанию размер тени совпадает с размером элемента, а ее цвет такой
          же как цвет ее текста
        </p>
        <div class="bg">
          <p>
            <b>box-shadow:</b> &lt;x-offset&gt; &lt;y-offset&gt; &lt;blur&gt;
            &lt;spread&gt; &lt;color&gt;
          </p>
        </div>
        <ul>
          <li>
            <b>x-offset</b> - горизонтальное смещение. Положительное значение
            смещает тень вправо от блока, отрицательное - влево. Обязательное
            значение.
          </li>
          <li>
            <b>y-offset</b> - Вертикальное смещение, положительное - вниз,
            отрицательное - вверх. Обязательное значение.
          </li>
          <li>
            <b>blur</b> - радиус размытия. Чем больше значение, тем сильнее
            размыта тень. Необязательное значение.
          </li>
          <li>
            <b>spread</b> - радиус распространения. Положительное значение
            увеличивает тень, отрицательное уменьшает. Необязательное значение.
          </li>
          <li>
            <b>color</b> - цвет тени. Можно использовать любой формат записи
            цвета. Необязательное значение.
          </li>
        </ul>
        <div class="shadow">
          <h4>Lorem ipsum dolor sit amet.</h4>
          <p>
            Lorem ipsum dolor, sit amet consectetur adipisicing elit. Rem
            possimus maxime mollitia, aspernatur laborum dolores unde reiciendis
            ipsum expedita. Corrupti.
          </p>
        </div>
        <div class="card__set">
          <article class="post">
            <h1 class="post__title">Lorem ipsum dolor sit amet</h1>
            <p class="post__text">
              Lorem ipsum dolor sit amet consectetur adipisicing elit.
            </p>
          </article>

          <article class="post">
            <h1 class="post__title">Lorem ipsum dolor sit amet</h1>
            <p class="post__text">
              Lorem ipsum dolor sit amet consectetur adipisicing elit.
            </p>
          </article>

          <article class="post">
            <h1 class="post__title">Lorem ipsum dolor sit amet</h1>
            <p class="post__text">
              Lorem ipsum dolor sit amet consectetur adipisicing elit.
            </p>
          </article>

          <article class="post">
            <h1 class="post__title">Lorem ipsum dolor sit amet</h1>
            <p class="post__text">
              Lorem ipsum dolor sit amet consectetur adipisicing elit.
            </p>
          </article>
        </div>
        <h3 class="title">Внутренняя тень</h3>
        <p>
          Если внешняя тень визуально примоднимает элемент, то внутренняя тень
          позволяет добавить элемент глубины, вдавливая элемент в интерфейс.
          Синтаксис объявления внутренней тени аналогичен обычной, но первым
          значением необходимо указать inset.
        </p>
        <div class="bg">
          <p>
            <b>box-shadow:</b> inset &lt;x-offset&gt; &lt;y-offset&gt;
            &lt;blur&gt; &lt;spread&gt; &lt;color&gt;
          </p>
        </div>
        <p>
          Смещение, размытие и распростронение тени происходят внутри элемента и
          визуально ограничено его рамкой.
        </p>
        <article class="post__inset">
          <h1 class="post__title-inset">Lorem ipsum dolor sit amet</h1>
          <p class="post__text-inset">
            Lorem ipsum dolor sit amet consectetur adipisicing elit. Voluptas id
            eius sunt quas eos accusantium! Pariatur alias reiciendis nesciunt
            fuga repellat aperiam, omnis eligendi. Ut accusantium ea molestias
            totam eum harum facere adipisci placeat reiciendis, consequatur aut
            officia non obcaecati dolor quia laboriosam consequuntur odio, sed
            sint fuga nam.
          </p>
        </article>
        <h3 class="title">Многослойная тень</h3>
        <p>
          На один элемент можно добавить несколько теней, указав их через
          запятую.
        </p>
        <div class="bg">
          <p>
            <b>box-shadow:</b> <br />
            &lt;x-offset&gt; &lt;y-offset&gt; &lt;blur&gt; &lt;spread&gt;
            &lt;color&gt;,<br />
            &lt;x-offset&gt; &lt;y-offset&gt; &lt;blur&gt; &lt;spread&gt;
            &lt;color&gt;, <br />
            &lt;x-offset&gt; &lt;y-offset&gt; &lt;blur&gt; &lt;spread&gt;
            &lt;color&gt;, <br />
            ...
          </p>
        </div>
        <p>
          Получается многослойный пирог, в котором первая тень в списке
          размещается в самом верху, последняя в самом низу, т.е чем раньше
          указана тень, тем выше она в слоях и будет визуально перекрывать все
          последующие. Этот подход позволяет сделать очень мягкие и красивые
          тени.
        </p>
        <article class="post__shadow">
          <h1 class="post__title">Lorem ipsum dolor sit amet</h1>
          <p class="post__text">
            Lorem ipsum dolor sit amet consectetur adipisicing elit. Voluptas id
            eius sunt quas eos accusantium! Pariatur alias reiciendis nesciunt
            fuga repellat aperiam, omnis eligendi. Ut accusantium ea molestias
            totam eum harum facere adipisci placeat reiciendis, consequatur aut
            officia non obcaecati dolor quia laboriosam consequuntur odio, sed
            sint fuga nam.
          </p>
        </article>
        <h3 class="title">Векторная графика</h3>
        <img src="./image/raster-vs-vector.png" alt="" class="img" />
        <p>
          svg (scalable vector graphics) - формат графики и язык для описания
          векторных изображений. Внутри файла небинарный, а обычный текст (xml),
          описывающий объект, их эффекты и поведение
        </p>
        <p>Векторная графика имеет ряд преимуществ.</p>
        <ul>
          <li>
            <b>Масштабирование</b> в отличие от расторной графики svg не теряет
            качество при масштабировании.
          </li>
          <li>
            <b>Размер файла</b>. Вектороное изображение весит намного меньше
            растровых, если используется для иконок или другой абстрактной
            графики. Использование вектора для фотореалистичных изображений
            наоборот ведет к огромному размеру файла.
          </li>
          <li>
            <b>Динамичность</b>. При помощи css и js можно изменить параметры
            векторного изображения, например цвет или рамки.
          </li>
        </ul>
        <h3 class="title">SVG элементы</h3>
        <p>
          Любое векторное изображение состоит из набора фигур, которые
          представлены svg єлементами. Когда дизайнер экспортирует иконку из
          графического редактора, например adobe или strator, программа
          переводит изображение в набор элементов и получается svg файл.
          Разработчик использует готовое svg изображение, не задумываясб о его
          содержимом, но базовое знакомство с элементами не будет лишним.
          Поэтому рассмотрим некоторые из них.
        </p>
        <h3 class="title">Элемент &lt;svg&gt;</h3>
        <p>
          Определяет холст, на котором можно рисовать фигуры. Сделаем холст
          400*300px и добавим ему встроенный стиль outline для визуальной
          границы.
        </p>
        <div class="bg">
          <p>index.html</p>
          <p>
            &lt;svg width=&quot;400&quot; height=&quot;300&quot; style=&quot;
            outline: 2px dashed #2a2a2a;&quot;&gt;<br />
            &lt;!-- Тут будет разметка фигур --&gt; <br />
            &lt;/svg&gt;
          </p>
        </div>
        <h3 class="title">Элемент &lt;rect &gt;</h3>
        <p>
          Создает прямоугольную область. нарисуем прямоугольник 250*150px и
          добавим след хар-ки.
        </p>
        <ul>
          <li>Зальем цветом, используя атрибут fill</li>
          <li>
            Установим рамку черного цвета шириной 4px с атрибутами stroke и
            stroke-width
          </li>
          <li>
            Зададим смещение 20px по вертикали и горизонтали относительно
            верхнего угла холста атрибутами х и у
          </li>
          <li>
            Добавим скругление углов прямоугольника атрибутами rx (по
            горизонтали) и ry (по вертикали).Если задать только одно значение то
            другое будет идентично
          </li>
        </ul>
        <div class="bg">
          <p>index.html</p>
          <p>
            &lt;svg width=&quot;400&quot; height=&quot;300&quot;
            style=&quot;outline: 1px solid black;&quot;&gt; <br />
            &lt;rect <br />
            width=&quot;250&quot; <br />
            height=&quot;150&quot; <br />
            fill=&quot;tomato&quot; <br />
            stroke=&quot;black&quot; <br />
            stroke-width=&quot;4&quot; <br />
            x=&quot;20&quot; <br />
            y=&quot;20&quot; <br />
            rx=&quot;40&quot; <br />
            /&gt; <br />
            &lt;/svg&gt; <br />
          </p>
        </div>
        <p>
          Нарисуем еще один прямоугольник и разместим его в нижней правой части
          угла. Новая фигура перекроет первый прямоугольник, потому что
          располагается как в слоеном пироге. Ниже в разметке значет выше в
          слоях на холсте.
        </p>
        <svg width="400" height="300" style="outline: 2px dashed #2a2a2a">
          <rect
            width="250"
            height="150"
            fill="tomato"
            stroke="#2a2a2a"
            stroke-width="4"
            x="20"
            y="20"
            rx="40"
          />
          <rect
            width="250"
            height="150"
            fill="orange"
            stroke="#2a2a2a"
            stroke-width="4"
            x="120"
            y="120"
            rx="60"
            ry="30"
          />
          <rect
            width="200"
            height="100"
            fill="blue"
            stroke="#2a2a2a"
            stroke-width="4"
            x="150"
            y="150"
            rx="80"
            ry="20"
          />
        </svg>
        <h3 class="title">Элемент &lt;circle &gt;</h3>
        <p>
          Создает окружность, радиус которой задается атрибутом r. Нарисуем эту
          фигуру размером 100*100px, дадим ей рамку и зальем цветом. Получится
          окружность с цетром в верхнем левом углу, большая часть которой
          скрыта. т.к находится за холстом
        </p>
        <div class="bg">
          <p>
            &lt;svg width=&quot;400&quot; height=&quot;300&quot;
            style=&quot;outline: 2px dashed #2a2a2a;&quot;&gt; <br />
            &lt;circle r=&quot;100&quot; fill=&quot;tomato&quot;
            stroke=&quot;#2a2a2a&quot; stroke-width=&quot;4&quot; /&gt; <br />
            &lt;/svg&gt;
          </p>
        </div>
        <p>
          Коодирдинаты центра окружности на холсте задаются атрибутами сх
          (center х) и сy (center y)
        </p>
        <svg width="400" height="300" style="outline: 2px dashed #2a2a2a">
          <circle
            r="50"
            cx="100"
            cy="100"
            fill="tomato"
            stroke="#2a2a2a"
            stroke-width="4"
          />
        </svg>
        <h3 class="title">Элемент &lt;ellipse &gt;</h3>
        <p>
          Создает эллипс. Горизонтальный и вертикальный радиус задается
          атрибутами rx и ry. Остальные атрибуты совпадают с элементами
          &lt;circle &gt;. Нарисуем эллипс 150*100px. Дадим ему рамку и зальем
          цветом.
        </p>
        <svg width="400" height="300" style="outline: 2px dashed #2a2a2a">
          <ellipse
            rx="150"
            ry="100"
            cx="200"
            cy="150"
            fill="tomato"
            stroke="#2a2a2a"
            stroke-width="4"
          />
        </svg>
        <h3 class="title">Элемент &lt;line &gt;</h3>
        <p>
          Создает примую линию. Атрибуты х1 и у1 указывают точку начала линии, а
          х2 и у2 ее конец. Нарисуем на холсте иконку гамбургер меню из трех
          параллельных горизонтальных линий.
        </p>
        <div class="bg">
          <p>
            &lt;svg width=&quot;400&quot; height=&quot;300&quot;
            style=&quot;outline: 2px dashed #2a2a2a;&quot;&gt; <br />
            &lt;line x1=&quot;20&quot; y1=&quot;50&quot; x2=&quot;380&quot;
            y2=&quot;50&quot; stroke=&quot;#2a2a2a&quot;
            stroke-width=&quot;16&quot; /&gt; <br />
            &lt;line x1=&quot;20&quot; y1=&quot;80&quot; x2=&quot;380&quot;
            y2=&quot;80&quot; stroke=&quot;#2a2a2a&quot;
            stroke-width=&quot;16&quot; /&gt; <br />
            &lt;line x1=&quot;20&quot; y1=&quot;110&quot; x2=&quot;380&quot;
            y2=&quot;110&quot; stroke=&quot;#2a2a2a&quot;
            stroke-width=&quot;16&quot; /&gt; <br />
            &lt;/svg&gt;
          </p>
        </div>
        <svg width="400" height="165" style="outline: 2px dashed #2a2a2a">
          <line
            x1="20"
            y1="50"
            x2="380"
            y2="50"
            stroke="#2a2a2a"
            stroke-width="16"
          />
          <line
            x1="20"
            y1="80"
            x2="380"
            y2="80"
            stroke="#2a2a2a"
            stroke-width="16"
          />
          <line
            x1="20"
            y1="110"
            x2="380"
            y2="110"
            stroke="#2a2a2a"
            stroke-width="16"
          />
        </svg>
        <h3 class="title">Элемент &lt;polygon &gt;</h3>
        <p>
          Описывает многоугольник, вид которого определяется атрибутом points -
          набором точек в виде координат линий, которые разделены на группы
        </p>
        <div class="bg">
          <p>
            &lt;svg width=&quot;600&quot; height=&quot;300&quot;
            style=&quot;outline: 2px dashed #2a2a2a;&quot;&gt; <br />
            &lt;polygon <br />
            points=&quot;20,20 20,200 200,200 200,20&quot; <br />
            fill=&quot;orange&quot; <br />
            stroke=&quot;#2a2a2a&quot; <br />
            stroke-width=&quot;4&quot; <br />
            /&gt; <br />
            &lt;/svg&gt;
          </p>
        </div>
        <p>
          Первая цифра группы координаты х, вторая цифра после запятой
          координата у. Первая группа цифр определяет начало первой линии,
          вторая группа определяет конец первой линии и одновременно начало
          второй линии и т.д. Polygon это замкнутая фигура, поэтому последняя
          замыкающая линия добавляется автоматически, соеденяя конец последней
          линии с началом первой линии фигуры.
        </p>
        <svg width="600" height="300" style="outline: 2px dashed #2a2a2a">
          <!-- Квадрат -->
          <polygon
            points="20,20 20,200 200,200 200,20"
            fill="orange"
            stroke="#2a2a2a"
            stroke-width="4"
          />

          <!-- Трехугольник -->
          <polygon
            points="250,20 250,200 400,200"
            fill="skyblue"
            stroke="#2a2a2a"
            stroke-width="4"
          />

          <!-- Параллелограмм -->
          <polygon
            points="430,20 430,200 550,250 550, 70"
            fill="palevioletred"
            stroke="#2a2a2a"
            stroke-width="4"
          />
        </svg>
        <h3 class="title">Элемент &lt;path &gt;</h3>
        <p>
          Универсальный элемент для представления фигуры любой сложности. Все
          svg иконки экспортируемые дизайнером опысаны этим элементом. Атрибут d
          содержит набор координат и соединяющих их кривых, определяющих
          направление линий. Вручную редактировать path не нужно. Иконки
          рисуются в спец редакторах которые при экпорте заполняют path и другие
          элементы и атрибуты.
        </p>
        <svg
          viewBox="0 -10 511.991 511"
          xmlns="http://www.w3.org/2000/svg"
          width="300"
          height="300"
          style="outline: 2px dashed #2a2a1a"
        >
          <path
            d="M510.652 185.883a27.177 27.177 0 00-23.402-18.688l-147.797-13.418-58.41-136.75C276.73 6.98 266.918.497 255.996.497s-20.738 6.483-25.023 16.53l-58.41 136.75-147.82 13.418c-10.837 1-20.013 8.34-23.403 18.688a27.25 27.25 0 007.937 28.926L121 312.773 88.059 457.86c-2.41 10.668 1.73 21.7 10.582 28.098a27.087 27.087 0 0015.957 5.184 27.14 27.14 0 0013.953-3.86l127.445-76.203 127.422 76.203a27.197 27.197 0 0029.934-1.324c8.851-6.398 12.992-17.43 10.582-28.098l-32.942-145.086 111.723-97.964a27.246 27.246 0 007.937-28.926zM258.45 409.605"
            fill="#2a2a2a"
          />
        </svg>
        <h3 class="title">svg документ</h3>
        <p>
          Векторную графику хранят в файлах с расширением .svg. Это обычный
          текстовый файл, в котором на верхнем уровне находится тег &lt;svg&gt;
          с набором служебных атрибутов, указывающих в какой версии языка
          разметки и согласно какой версии svg спецификации написан документ. Из
          всех служебных только атрибут xmlns является обязательным, остальные
          обычно пропускают.
        </p>
        <div class="bg">
          <p>
            &lt;svg <br />
            version=&quot;1.1&quot; <br />
            xmlns=&quot;http://www.w3.org/2000/svg&quot; <br />
            xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; <br />
            xmlns:ev=&quot;http://www.w3.org/2001/xml-events&quot; <br />
            &gt; <br />
            &lt;circle r=&quot;75&quot; cx=&quot;50%&quot; cy=&quot;50%&quot;
            <br />
            fill=&quot;tomato&quot; /&gt; <br />&lt;/svg&gt; <br />
          </p>
        </div>
        <p>
          Если сохранить этот код во внешнем файле, например icon.svg и добавить
          на веб страницу исполюзуя &lt;img&gt; браузер нарисует холст 350*150px
          (по умолчанию) в центре которого будет окружность.
        </p>
        <p class="information">
          Если явно не задать размер браузер по умолчанию устанавливает размер
          элементов 350*150px, все что не поместилось обрежется.
        </p>
        <h3 class="title">svg viewport</h3>
        <p>
          Содержимое svg документа отрисовывается на бесконечном холсте и может
          быть сколь угодно большого размера, но видимая часть холста
          соответствует размерам элемента &lt;svg&gt;. Атрибуты width и height
          задают размер рабочей области просмотра (viewport). Верхний левый угол
          области просмотра это начало координат, где х=0 и у=0, по умолчанию
          используются пиксели, поэтому указывать px излишне.
        </p>
        <div class="bg">
          <p>
            &lt;svg <br />
            xmlns=&quot;http://www.w3.org/2000/svg&quot; <br />
            width=&quot;400&quot; <br />
            height=&quot;200&quot; <br />
            style=&quot;outline: 2px dashed #2a2a2a;&quot;<br />
            &gt;<br />
            &lt;circle r=&quot;75&quot; cx=&quot;50%&quot; cy=&quot;50%&quot;
            fill=&quot;tomato&quot; /&gt; <br />
            &lt;/svg&gt;
          </p>
        </div>
        <h3 class="title">svg viewBox</h3>
        <p>
          Если перевести viewBox то буквально получим "окно просмотра", т.е это
          окно, через которое можно просматривать некоторую часть svg документа.
          Что то похожее на окно иллюминатора в самолете, через который вы
          можете видеть окружающий мир, но viewBox так же может масштабировать
          (приблизить или отдалить) картинку как телескоп.
        </p>
        <img src="./image/viewbox.svg" alt="" />
        <p>
          Атрибут viewBox определяет какая часть изображения будет отображена и
          в каком масштабе.
        </p>
        <p class="bg">viewBox="x y width height"</p>
        <div>
          <p class="bg">&lt;svg viewBox=&quot;0 0 400 200&quot;&gt;</p>
          <svg
            class="vector"
            xmlns="http://www.w3.org/2000/svg"
            width="200"
            height="200"
            viewBox="100 100 400 200"
            style="outline: 2px dashed #2a2a2a"
          >
            <circle r="75" cx="50%" cy="50%" fill="tomato" />
          </svg>
        </div>
        <p>
          Если соотнешине значений атрибутов width и height к их аналогам в
          viewBox равно 1к1 изображение будет отрисовано в оригинальном размере.
        </p>
        <p class="bg">
          &lt;svg width=&quot;400&quot; height=&quot;200&quot; viewBox=&quot;0 0
          400 200&quot;&gt; <br />
          &lt;circle r=&quot;75&quot; cx=&quot;50%&quot; cy=&quot;50%&quot;
          fill=&quot;tomato&quot; /&gt; <br />
          &lt;/svg&gt;
        </p>
        <p>
          При соотношении 2к1 оригинальное изображение будет увеличено в
          масштабе равному в 2 раза, но размеры элемента останутся прежними
        </p>
        <p class="bg">
          &lt;svg width=&quot;400&quot; height=&quot;200&quot; viewBox=&quot;0 0
          200 100&quot;&gt; <br />
          &lt;circle r=&quot;75&quot; cx=&quot;50%&quot; cy=&quot;50%&quot;
          fill=&quot;tomato&quot; /&gt; <br />
          &lt;/svg&gt;
        </p>
        <p>
          При соотношении 1к2 оригинально изображение будет уменьшено в масштабе
          равное в 2 раза, но размеры элемента останутся прежними 400*200px
        </p>
        <p class="bg">
          &lt;svg width=&quot;400&quot; height=&quot;200&quot; viewBox=&quot;0 0
          800 400&quot;&gt; <br />
          &lt;circle r=&quot;75&quot; cx=&quot;50%&quot; cy=&quot;50%&quot;
          fill=&quot;tomato&quot; /&gt; <br />
          &lt;/svg&gt;
        </p>
        <p class="warning">
          Т.е viewBox это окно через которое пользователь смотрит на svg
          документ. Оно может быть перемещено в любое место svg документа и
          пользователь увидит фрагмент, который находится непосредственно под
          viewBox, согласно заданому масштабу.
        </p>
        <h3 class="title">Использование</h3>
        <p>
          Есть несколько способов использование векторной графики, каждый имеет
          свои плюсы и минусы.
        </p>
        <h4 class="title">В элементе &lt;img&gt;</h4>
        <p>
          Такой подход ничем не отличается от использования растровых
          изображений. Достаточно указать путь к изображению и зададим 3
          элемента img разных размеров и используем одну и ту же svg иконку.
          Пикселизации нет, даже если максимально масштабировать веб страницу,
          потому что в элементе img вектор так же рисуется браузером по заданым
          формулам внутри svg файла
        </p>
        <div class="bg">
          <img
            src="https://res.cloudinary.com/goit-academy/image/upload/v1614773221/codepen/cat_segyum.svg"
            width="60"
          />
          <img
            src="https://res.cloudinary.com/goit-academy/image/upload/v1614773221/codepen/cat_segyum.svg"
            width="120"
          />
          <img
            src="https://res.cloudinary.com/goit-academy/image/upload/v1614773221/codepen/cat_segyum.svg"
            width="180"
          />
          <img
            src="https://res.cloudinary.com/goit-academy/image/upload/v1614773221/codepen/cat_segyum.svg"
            width="80"
          />
        </div>
        <h3 class="title">Как фон элемента</h3>
        <p>
          Векторное изображение может использоваться как фоновое изображение
          через background-image. Можно делать любые манипуляции с векторным
          фоном так же как и с растровой графикой
        </p>
        <div class="box"></div>
        <h3 class="title">Встроенный svg документ</h3>
        <p>
          Предыдущие 2 метода подходят для статической графики, например
          абстрактного фона или иконок, для которых не нужно добавлять элементы
          ховера и фокуса. Но у них есть один существенный недостаток - нет
          возможности изменить динамический цвет или другие хар-ки векторного
          изображения из css. svg изображение можно добавить целиком в html, это
          называется встроенный svg (inline svg), т.е открыть svg файл в
          тектовом редакторе, скопировать содержимое и вставить его в html
          документ. Так можно обратиться к его внутренней структуре. В примере
          мы добавляем элементу svg.icon устанавливаем базовый черный цвет
          заливки (свойство fill) и меняем его при ховере на оранжевый.
        </p>

        <p>У такого подхода есть ряд существенных минусов</p>
        <ul>
          <li>Встроенный svg код увеличивает размер html файла</li>
          <li>
            Невозможно повторно использовать одно и тоже изображение без
            дублирования кода
          </li>
          <li>Поддержка и правки встроенного svg труднозатратны</li>
          <li>
            Браузер не может кешировать встроенные фигуры в отличае от svg
            файлов
          </li>
        </ul>
        <h3 class="title">svg sprite</h3>
        <p>
          svg sprite это современная техника, которую применяют в большинстве
          случаев.
        </p>
        <ul>
          <li>Один файл для всех svg иконок веб сайта</li>
          <li>
            Файл spite кешируется браузером и не будет загруден при повторных
            посещениях
          </li>
          <li>
            Иконкам в sprite можно изменять цвет и другие хар-ки через css
          </li>
        </ul>
        <p>
          svg документ - это просто текстовый файл, внутри которого, в отличие
          от растровой графики описаны фигуры, которые отрисует браузер. Внутри
          одного файла можно описать множество разных групп фигур использую
          элемент symbol, после чего, дав каждому символу уникальный id,
          обратится к любому из них html документа можно через #
        </p>
        <p class="bg">
          index.html <br />
          &lt;svg&gt; <br />
          &lt;use
          href=&quot;./путь-к-свг-спрайту/имя-спрайта.svg#идентификатор-символа&quot;&gt;&lt;/use&gt;
          <br />
          &lt;/svg&gt;
        </p>
        <p>
          Для использования иконок sprite в html документе необходимо добавить
          разметку элемента svg и вложеного в него элемента use с атрибутом
          href, в котором указан путь к иконке. Путь задается как к обычному
          файлу, но в конце добавляется # с индификатором id.
        </p>
        <div class="bg">
          <svg
            aria-hidden="true"
            style="position: absolute; width: 0; height: 0"
            xmlns="http://www.w3.org/2000/svg"
            overflow="hidden"
          >
            <defs>
              <!-- Trash can icon -->
              <symbol id="delete" viewBox="0 0 32 32">
                <path
                  d="M8 25.333C8 26.8 9.2 28 10.667 28h10.667c1.467 0 2.667-1.2 2.667-2.667v-16h-16v16zm17.333-20h-4.667L19.333 4h-6.667l-1.333 1.333H6.666V8h18.667V5.333z"
                />
              </symbol>
              <!-- Camera icon -->
              <symbol id="camera" viewBox="0 0 32 32">
                <path
                  d="M20.267 16a4.267 4.267 0 11-8.534 0 4.267 4.267 0 018.534 0z"
                />
                <path
                  d="M12 2.667L9.56 5.334H5.333a2.675 2.675 0 00-2.667 2.667v16c0 1.467 1.2 2.667 2.667 2.667h21.333c1.467 0 2.667-1.2 2.667-2.667v-16c0-1.467-1.2-2.667-2.667-2.667h-4.227l-2.44-2.667h-8zm4 20c-3.68 0-6.667-2.987-6.667-6.667S12.32 9.333 16 9.333 22.667 12.32 22.667 16 19.68 22.667 16 22.667z"
                />
              </symbol>
              <!-- Portfolio icon -->
              <symbol id="work" viewBox="0 0 32 32">
                <path
                  d="M26.667 8h-5.333V5.333a2.658 2.658 0 00-2.667-2.667h-5.333a2.658 2.658 0 00-2.667 2.667V8H5.334a2.646 2.646 0 00-2.653 2.667l-.013 14.667a2.658 2.658 0 002.667 2.667h21.333a2.658 2.658 0 002.667-2.667V10.667A2.658 2.658 0 0026.668 8zm-8 0h-5.333V5.333h5.333V8z"
                />
              </symbol>
            </defs>
          </svg>

          <ul class="icon-list">
            <li>
              <svg class="icon" width="80" height="80">
                <use href="#delete"></use>
              </svg>
            </li>
            <li>
              <svg class="icon" width="80" height="80">
                <use href="#camera"></use>
              </svg>
            </li>
            <li>
              <svg class="icon" width="80" height="80">
                <use href="#work"></use>
              </svg>
            </li>
          </ul>

          <p>
            Итак внутри svg sprite есть набор элементов svg и symbol,
            описывающий весь svg sprite целиком и каждую фигуру по отдельности.
            К каждому symbol задан уникальный идентификатор. В html используем
            атрибут href и обращаемся к svg symbol через # и его идетификатор.
          </p>
          <p class="warning">
            В примере весь svg sprite находится в html разметке, поэтому нет
            имени svg файла перед #. Если бы svg sprite лежал в отдельном файле,
            было бы обращено по имени, а потом # и id символа
          </p>
          <br />
          <div class="bg">
            <svg class="icon" width="60" height="30">
              <use href="./image/icons.svg#delete"></use>
            </svg>
            <svg class="icon" width="60" height="30">
              <use href="./image/icons.svg#camera"></use>
            </svg>
            <svg class="icon" width="60" height="30">
              <use href="./image/icons.svg#work"></use>
            </svg>
          </div>
          <br />
          <p class="bg">
            &lt;div&gt; <br />
            &lt;svg class=&quot;icon&quot; width=&quot;60&quot;
            height=&quot;30&quot;&gt; <br />
            &lt;use href=&quot;./images/icons.svg#delete&quot;&gt;&lt;/use&gt;
            <br />
            &lt;/svg&gt; <br />
            &lt;svg class=&quot;icon&quot; width=&quot;60&quot;
            height=&quot;30&quot;&gt; <br />
            &lt;use href=&quot;./images/icons.svg#camera&quot;&gt;&lt;/use&gt;
            <br />
            &lt;/svg&gt; <br />
            &lt;svg class=&quot;icon&quot; width=&quot;60&quot;
            height=&quot;30&quot;&gt; <br />
            &lt;use href=&quot;./images/icons.svg#work&quot;&gt;&lt;/use&gt;
            <br />
            &lt;/svg&gt; <br />
            &lt;/div&gt;
          </p>
          <h3 class="title">Оформление фигур</h3>
          <p>
            В css можно динамически изменять некоторые хар-ки встроенного
            векторного изображения или иконки из svg спрайта например заливку,
            цвет или тип обводки. Значения можно задать как атрибутами svg фигур
            так и одноименными css свойствами. На практике для оформления фигур
            используют не атрибуты а css код, т.к его проще поддерживать и
            изменять.
          </p>
          <h3 class="title">Свойство fill</h3>
          <p>
            Управляет цветом заливки, цвет можно задавать в любом удобном
            формате. Если цвет заливки не указан, фигура будет залита текущим
            цветом текста, по умолчанию черным (#000). Полностью убрать заливку
            можно значением none, в результате получится полностью прозрачная
            фигура
          </p>
        </div>
        <p class="bg">
          /* Устанавливаем цвет заливки в спокойном состоянии. */ <br />
          .icon { <br />
          fill: #2a2a2a; <br />
          } <br />
          <br />

          /* Изменяем цвет заливки при ховере. */ <br />
          .icon:hover { <br />
          fill: #ff6347; <br />
          }
        </p>
        <h3 class="title">Свойство fill-opacity</h3>
        <p>
          Управляет только прозрачностью цвета заливки, а не всего цвета или
          элемента, т.е отличается от opacity или stroke-opacity. Например, если
          у иконки будет задана красная обводка, то на ее цвет это свойство не
          повлияет. Значение задается числом от 0 до 1.
        </p>
        <p class="bg">
          .icon { <br />
          fill: #2a2a2a; <br />
          fill-opacity: 0.7; <br />
          } <br />
          <br />

          /* fill-opacity также применится к новому цвету при ховере. */ <br />
          .icon:hover { <br />
          fill: #03a9f4; <br />
          }
        </p>
        <h3 class="title">Свойство stroke</h3>
        <p>
          Устанавливает цвет обводки. По умолчанию не имеет значения. Хар-ки
          обводки, например цвет и толщина задаются отдельными css свойствами
        </p>
        <p class="bg">
          .icon { <br />
          stroke: #f44336; <br />
          }
        </p>
        <h3 class="title">Свойство stroke-width</h3>
        <p>
          Контролирует толщину обводки, по умолчанию значение 1px. Поэтому для
          однопиксельной обводки достаточно указать цвет в св-ве stroke. Если
          задана толщина обводки, но не задан цвет, она не отобразится.
        </p>
        <p class="bg">
          .icon { <br />
          stroke: #f44336; <br />
          stroke-width: 3px; <br />
          }
        </p>
        <h3 class="title">Свойство stroke-opacity</h3>
        <p>
          Управляет только прозрачностю цвета обводки, а не всего цвета или
          элемента. Значение задается числом от 0 до 1.
        </p>
        <p class="bg">
          .icon { <br />
          stroke: #f44336; <br />
          stroke-width: 3px; <br />
          stroke-opacity: 0.7; <br />
          }
        </p>
        <div class="icons__test">
          <svg class="icon__test" width="50" height="50">
            <use href="./image/cat.svg#icon-cat"></use>
          </svg>
        </div>
        <h3 class="title">Декоративный оверлей</h3>
        <p>
          Свойство overflow со значением hidden используется при создании
          декоративного контента из-за границ блока.
        </p>
        <h2>Наведи курсор мыши на квадрат</h2>
        <div class="box">
          <div class="box__overlay">
            <p>
              Это содержимое скрыто посредством трансформации и появляется
              только при наведении курсора на <code>.box__overlay</code>
            </p>
          </div>
        </div>

        <p>
          Такой эффект реализуется в несколько простых шагов. Разберем стили для
          создания эффекта.
        </p>
        <p class="bg">
          &lt;div class=&quot;box&quot;&gt; <br />
          &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt; <br />
          &lt;/div&gt;
        </p>
        <p>
          Вначале абсолютно позиционируем <b>div.box__overlay</b> относительно
          <b>div.box</b> и растягиваем его на всю ширину и высоту div.box
        </p>
        <p class="bg">
          .box { <br />
          position: relative; <br />
          } <br /><br />

          .box__overlay {<br />
          position: absolute;<br />
          top: 0;<br />
          left: 0;<br />
          width: 100%;<br />
          height: 100%;<br />
          }
        </p>
        <p>
          Используя св-во transform и translatey смещаем div.box__overlay вверх
          на 100% его ширины
        </p>
        <p class="bg">
          .box__overlay { <br />
          position: absolute; <br />
          top: 0;<br />
          left: 0;<br />
          width: 100%;<br />
          height: 100%;<br />

          transform: translatey(-100%);<br />
          }
        </p>
        <p>
          При ховере по div.box используется trasform и transletex, возвращаем
          div.box__overlay в исходное положение
        </p>
        <p class="bg">
          .box:hover .box__overlay { <br />
          transform: translatey(0); <br />
          }
        </p>
        <p>
          Задаем div.box свойство overflow со значением hidden, чтобы визуально
          спрятать div.box__overlay когда тот смещен за пределы div.box
        </p>
        <p class="bg">
          .box { <br />
          position: relative; <br />
          overflow: hidden; <br />
          }
        </p>
        <p>
          Используем одно свойство для визуальзации появления оверлея. Добавляем
          div.box__overley переход для анимации свойства transform
        </p>
        <p class="bg">
          .box__overlay { <br />
          position: absolute;<br />
          top: 0;<br />
          left: 0;<br />
          width: 100%;<br />
          height: 100%;<br />

          transform: translateY(-100%);<br />
          transition: transform 250ms ease;<br />
          }
        </p>
      </div>
    </header>
  </body>
</html>
